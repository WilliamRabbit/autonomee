#!/usr/bin/env python

import math

from PySide import QtCore, QtGui, QtSvg

import svg
import engine
import heatmap
from collections import deque

class MainWindow(QtGui.QMainWindow):
    AUTO_MODE = 0
    MANUAL_MODE = 1
    def __init__(self):
        super(MainWindow, self).__init__()

        self.currentPath = ''

        self.automaticView = SvgView()
        self.manualView = ManualView()

        # File menu
        fileMenu = QtGui.QMenu("&File", self)
        openAction = fileMenu.addAction("&Open...")
        openAction.setShortcut("Ctrl+O")
        quitAction = fileMenu.addAction("E&xit")
        quitAction.setShortcut("Ctrl+Q")

        openAction.triggered.connect(self.openFile)
        quitAction.triggered.connect(QtGui.qApp.quit)

        self.menuBar().addMenu(fileMenu)

        # View menu
        viewMenu = QtGui.QMenu("&View", self)
        self.backgroundAction = viewMenu.addAction("&Background")
        self.backgroundAction.setEnabled(True)
        self.backgroundAction.setCheckable(True)
        self.backgroundAction.setChecked(True)
        self.backgroundAction.toggled.connect(self.automaticView.setViewBackground)

        self.menuBar().addMenu(viewMenu)

        # Mode menu
        modeMenu = QtGui.QMenu("&Mode", self)

        manualAction = modeMenu.addAction("M&anual")
        manualAction.setShortcut("Ctrl+M")
        manualAction.triggered.connect(self.manualMode)

        automaticAction = modeMenu.addAction("A&utomatic")
        automaticAction.setShortcut("Ctrl+A")
        automaticAction.triggered.connect(self.automaticMode)

        self.menuBar().addMenu(modeMenu)

        self.automaticMode()

    def manualMode(self):
        self.setCentralWidget(self.manualView)
        self.automaticView = SvgView()
        self.setWindowTitle("Carosif - Manual mode")

    def automaticMode(self):
        self.setCentralWidget(self.automaticView)
        self.manualView = ManualView()
        self.setWindowTitle("Carosif - Automatic mode")

    def openFile(self, path=None):
        if not path:
            path = QtGui.QFileDialog.getOpenFileName(self, "Open SVG File", self.currentPath, "SVG files (*.svg *.svgz *.svg.gz)")[0]
        if path:
            svg_file = QtCore.QFile(path)
            if not svg_file.exists():
                QtGui.QMessageBox.critical(self, "Open SVG File",
                        "Could not open file '%s'." % path)
                self.backgroundAction.setEnabled(False)
                return

            self.automaticView.openFile(svg_file)
            if not path.startswith(':/'):
                self.currentPath = path
                self.setWindowTitle("Carosif - Automatic mode - Map : {}".format(self.currentPath))
            self.backgroundAction.setEnabled(True)

            self.resize(self.automaticView.sizeHint() + QtCore.QSize(80, 80 + self.menuBar().height()))

            #self.svg = pysvg.parser.parse('mapexample.svg')

class ManualView(QtGui.QGraphicsView):

    def __init__(self, parent=None):
        super(ManualView, self).__init__(parent)

        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.SmoothPixmapTransform)

        self.setScene(ManualScene(self))

        tilePixmap = QtGui.QPixmap(64, 64)
        tilePixmap.fill(QtGui.QColor(230, 230, 230))
        self.setBackgroundBrush(QtGui.QBrush(tilePixmap))

    def paintEvent(self, event):
        super(ManualView, self).paintEvent(event)

class ManualScene(QtGui.QGraphicsScene):
    def __init__(self, parent=None):
        super(ManualScene, self).__init__(parent)

        # POUR LORIC : Ajoute ici les objets graphiques dont t'as besoin pour ta scene
        # Pour changer leur apparence, regarde tout ce qui est 'setPen', utilis&eacute; dans engine.py et ici

        # Ex1 un rectangle
        rect = QtGui.QGraphicsRectItem(10, 10, 200, 200)
        self.addItem( rect )

        # Ex2 une voiture
        self.car = engine.Car()
        self.car.setAngle(math.pi/2)
        self.addItem(self.car)

    def mousePressEvent(self, event):
        x, y = event.scenePos().x(), event.scenePos().y()

        super(ManualScene,self).mousePressEvent(event)

    def mouseMoveEvent(self, event):
        x, y = event.scenePos().x(), event.scenePos().y()
        super(ManualScene,self).mouseMoveEvent(event)

class ViewerScene(QtGui.QGraphicsScene):

    def __init__(self, parent=None):
        super(ViewerScene, self).__init__(parent)
        #self.setDragMode(QtGui.QGraphicsScene.ScrollHandDrag)

        self.x = 0
        self.y =0

        # Car object (model + graphics informations)
        self.car = None

        # Map generated by parsing an svg file
        self.map = None

        # The last generated path
        self.path = None

        # Graphical representation of the last generated path
        self.graphicalPath = None
        # self.graphicalPath = QtGui.QGraphicsPathItem( QtGui.QPainterPath() )
        # self.graphicalPath.setZValue(-1)


        # self.graphicalPath.setPen(pen)

        # self.addItem( self.graphicalPath )

        # Not used (as of 29/03), should be a graphic item for the car's "ray"
        self.ray = None

        # Heatmap, should be used for probabilities [WIP]
        self.heatmap = None
        # ( initialized when pressing 'H' )

    def mousePressEvent(self, event):
        x, y = event.scenePos().x(), event.scenePos().y()

        # If the car doesn't exist yet, we place it where we clicked
        if not self.car:
            self.car = engine.Car(self.map, x, y)
            self.addItem(self.car)

            #Fade in animation
            self.animation = QtCore.QPropertyAnimation(self.car, "opacity")
            self.animation.setDuration(300)
            self.animation.setStartValue( 0.0 )
            self.animation.setEndValue( 1.0 )
            self.animation.start( QtCore.QAbstractAnimation.DeleteWhenStopped )

        # If the car already exists, we generate a path from the car to where we clicked
        # and show it on the UI
        else:
            #We get the path from our 'map' object
            self.path = self.map.search((self.car.x(), self.car.y()), (x,y))

            if len(self.path) > 0:
                # We build a polyline graphic item
                painterPath = QtGui.QPainterPath()
                painterPath.moveTo(self.path[0].x, self.path[0].y)
                for i in xrange(1, len(self.path)):
                    painterPath.lineTo(self.path[i].x, self.path[i].y)

                # We set the path as the path to be shown on screen
                # self.graphicalPath.setPath(painterPath)

                 # If a path is already shown on screen, we just update it with the new path
                if self.graphicalPath is not None:
                    self.graphicalPath.setPath(painterPath)
                # Else, we create a new graphical path
                else:
                    self.graphicalPath = QtGui.QGraphicsPathItem(painterPath)
                    self.graphicalPath.setZValue(-1)

                    pen = QtGui.QPen()
                    pen.setColor(QtGui.QColor(180, 200, 240))
                    pen.setWidth(3)
                    # pen.setCapStyle(QtCore.Qt.RoundCap)
                    pen.setMiterLimit(10)
                    pen.setJoinStyle(QtCore.Qt.RoundJoin)
                    space = 4
                    pen.setDashPattern([8, space, 1, space] )
                    self.graphicalPath.setPen(pen)
                    self.graphicalPath.setOpacity(0.8)

                    self.addItem( self.graphicalPath )

                # Calculating the animation speed
                totalLength = painterPath.length()
                pixelsPerSecond = 200.0
                totalDuration = 1000. * (totalLength / pixelsPerSecond)

                # Animating the car on the path
                self.animation = QtCore.QParallelAnimationGroup();

                self.posAnim = QtCore.QPropertyAnimation(self.car, "pos")
                self.rotationAnim = QtCore.QPropertyAnimation(self.car, "angleProperty")

                self.posAnim.setDuration(totalDuration)
                self.rotationAnim.setDuration(totalDuration)

                self.posAnim.setKeyValueAt(0, self.car.pos())
                self.rotationAnim.setKeyValueAt(0, self.car.rotation())

                nKeys = len(self.path) - 1
                angles = deque()
                angles.append(self.car.rotation())

                for i in xrange(1, len(self.path)):
                    pt = self.path[i]
                    lastPt = self.path[i-1]

                    # Current angle calculus and format according to the trigonometric sens
                    angle = math.pi - math.atan2(lastPt.y - pt.y, lastPt.x - pt.x)
                    if angle > math.pi:
                        angle = angle - 2*math.pi

                    # We add the 'current angle' to the angles queue and calculate the mean
                    angles.append(angle)
                    meanAngle = sum(angles) / len(angles)

                    # If we already have many angles, with drop the oldest one
                    if len(angles) > 15:
                        angles.popleft()

                    self.posAnim.setKeyValueAt(float(i)/nKeys, QtCore.QPointF(pt.x, pt.y))
                    self.rotationAnim.setKeyValueAt(float(i)/nKeys, meanAngle)

                self.animation.addAnimation(self.rotationAnim)
                self.animation.addAnimation(self.posAnim)

                self.animation.finished.connect(self.pathFinished)

                self.animation.start(QtCore.QAbstractAnimation.DeleteWhenStopped)
                self.car.moving = True

        super(ViewerScene,self).mousePressEvent(event)

    # Called when the car have arried to the path's end
    def pathFinished(self):
        self.car.moving = False
        self.path =  []
        self.graphicalPath.setPath(QtGui.QPainterPath())

    def mouseMoveEvent(self, event):
        x, y = event.scenePos().x(), event.scenePos().y()

        if self.car and not self.car.moving:
            #We calculate the angle (in radians) and convert it to the trigonometric referential
            angle = math.pi - math.atan2(self.car.y() - y, self.car.x() - x)
            if angle > math.pi:
                angle = angle - 2*math.pi

            self.car.setAngle(angle)

    def keyPressEvent(self, event):

        # Moving the car
        speed = 20
        if self.car and not self.car.moving:
            if event.key()==QtCore.Qt.Key_Up or event.key()==QtCore.Qt.Key_Z:
                self.car.move(speed)
            elif event.key()==QtCore.Qt.Key_Down or event.key()==QtCore.Qt.Key_S:
                self.car.move(-speed)
            print self.car.x(), self.car.y()

        # Heatmap
        if event.key() == QtCore.Qt.Key_H:
            self.heatmap = heatmap.Heatmap(self.map.width ,  self.map.height)
            self.graphicalHeatmap = heatmap.GraphicalHeatmap(self.heatmap)
            self.graphicalHeatmap.setZValue(-1)
            self.addItem( self.graphicalHeatmap )

class SvgView(QtGui.QGraphicsView):
    Native, OpenGL, Image = range(3)

    def __init__(self, parent=None):
        super(SvgView, self).__init__(parent)

        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.SmoothPixmapTransform)

        self.renderer = SvgView.OpenGL
        self.svgItem = None
        self.backgroundItem = None
        self.outlineItem = None
        self.image = QtGui.QImage()

        self.setScene(ViewerScene(self))
        self.setTransformationAnchor(QtGui.QGraphicsView.AnchorUnderMouse)
        self.setDragMode(QtGui.QGraphicsView.ScrollHandDrag)

        self.setBackgroundBrush(QtGui.QImage("img/blueprintDark.png"))
        self.setCacheMode(QtGui.QGraphicsView.CacheBackground)


    def openFile(self, svg_file):
        if not svg_file.exists():
            return

        s = self.scene()

        #Reset the zoom factor
        self.factor = 1
        #Reset the car
        s.car = None
        #Recreate a map tree by parsing the SVG
        s.map = svg.SvgTree(svg_file.fileName())
        s.path = None
        s.graphicalPath = None

        if self.backgroundItem:
            drawBackground = self.backgroundItem.isVisible()
        else:
            drawBackground = False

        # if self.outlineItem:
        #     drawOutline = self.outlineItem.isVisible()
        # else:
        #     drawOutline = True

        s.clear()
        self.resetTransform

        # View containg the SVG map
        self.svgItem = QtSvg.QGraphicsSvgItem(svg_file.fileName())
        self.svgItem.setFlags(QtGui.QGraphicsItem.ItemClipsToShape)
        self.svgItem.setCacheMode(QtGui.QGraphicsItem.NoCache)
        self.svgItem.setZValue(0)
        s.addItem(self.svgItem)

        # Title text
        self.titleItem = QtGui.QGraphicsTextItem("INSAbot visualization UI")
        self.titleItem.setFont(QtGui.QFont("Ubuntu-L.ttf", 35, QtGui.QFont.Light))
        # 'Dirty' centering of the text
        self.titleItem.setPos(self.svgItem.boundingRect().width()/2 - self.titleItem.boundingRect().width()/2, 5)
        self.titleItem.setDefaultTextColor(QtGui.QColor(210, 220, 250))
        s.addItem(self.titleItem)
        # Drop shadow on the text
        self.textShadow = QtGui.QGraphicsDropShadowEffect()
        self.textShadow.setBlurRadius(3)
        self.textShadow.setColor( QtGui.QColor(20, 20, 40) )
        self.textShadow.setOffset(1, 1)
        self.titleItem.setGraphicsEffect( self.textShadow )


        # Background (blueprint image)
        self.backgroundItem = QtGui.QGraphicsRectItem(self.svgItem.boundingRect())
        self.backgroundItem.setBrush( QtGui.QImage("img/blueprint.png") )
        self.backgroundItem.setPen(QtGui.QPen())
        self.backgroundItem.setVisible(not drawBackground)
        self.backgroundItem.setZValue(-1)
        s.addItem(self.backgroundItem)

        #Shadow effect on the background
        self.shadow = QtGui.QGraphicsDropShadowEffect()
        self.shadow.setBlurRadius(50)
        self.shadow.setColor( QtGui.QColor(20, 20, 40) )
        self.shadow.setOffset(0, 0)
        self.backgroundItem.setGraphicsEffect( self.shadow )

        # # A dashed (outline) of the SVG map
        # self.outlineItem = QtGui.QGraphicsRectItem(self.svgItem.boundingRect())
        # outline = QtGui.QPen(QtCore.Qt.black, 2, QtCore.Qt.DashDotLine)
        # outline.setCosmetic(True)
        # self.outlineItem.setPen(outline)
        # self.outlineItem.setBrush(QtGui.QBrush(QtCore.Qt.NoBrush))
        # self.outlineItem.setVisible(drawOutline)
        # self.outlineItem.setZValue(1)
        # s.addItem(self.outlineItem)

        self.x = 0
        self.y = 0

        self.updateScene()

    def updateScene(self):
        self.scene().setSceneRect(self.svgItem.boundingRect().adjusted(self.x-10, self.y-10, self.x+10, self.y+10))

    def setRenderer(self, renderer):
        self.renderer = renderer
        self.setViewport(QtGui.QWidget())

    def setViewBackground(self, enable):
        if self.backgroundItem:
            self.backgroundItem.setVisible(enable)

    def setViewOutline(self, enable):
        if self.outlineItem:
            self.outlineItem.setVisible(enable)

    def wheelEvent(self, event):
        factor = 1.2**(event.delta() / 240.0)

        self.scale(factor, factor)

        event.accept()


if __name__ == '__main__':

    import sys

    app = QtGui.QApplication(sys.argv)

    window = MainWindow()
    if len(sys.argv) == 2:
        window.openFile(sys.argv[1])
    else:
        window.openFile('maps/mapexample.svg')
    window.show()
    sys.exit(app.exec_())
